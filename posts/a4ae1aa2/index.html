<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="V-ZJGOulkaRpRqqRLAsWlKCWXGC3sHJHsqR5SNu0HBY"><meta name="baidu-site-verification" content="oYV9dShRaO"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="caffeine cache"><meta name="description" content="Caffeine是一个高性能，高命中率，低内存占用，near optimal的本地缓存，本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。"><meta name="keywords" content="caffeine cache"><meta property="og:type" content="article"><meta property="og:title" content="Caffeine高性能设计剖析"><meta property="og:url" content="https://albenw.github.io/posts/a4ae1aa2/index.html"><meta property="og:site_name" content="Alben&#39;s home"><meta property="og:description" content="Caffeine是一个高性能，高命中率，低内存占用，near optimal的本地缓存，本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__0.png"><meta property="og:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__1.png"><meta property="og:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__2.png"><meta property="og:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__3.png"><meta property="og:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__4.png"><meta property="og:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__5.png"><meta property="og:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__6.png"><meta property="og:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__7.png"><meta property="og:updated_time" content="2019-12-26T10:24:41.488Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Caffeine高性能设计剖析"><meta name="twitter:description" content="Caffeine是一个高性能，高命中率，低内存占用，near optimal的本地缓存，本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。"><meta name="twitter:image" content="https://albenw.github.io/images/Caffeine高性能设计剖析__0.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://albenw.github.io/posts/a4ae1aa2/"><title>Caffeine高性能设计剖析 | Alben's home</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Alben's home</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">在这里，你会了解的更多，更透切</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook" rel="section"><i class="menu-item-icon fa fa-fw fa-comment"></i><br>留言</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://albenw.github.io/posts/a4ae1aa2/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="alben.wong"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Alben's home"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Caffeine高性能设计剖析</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-17T17:01:00+08:00">2019-12-17 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span> </a></span>， <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/caffeine/" itemprop="url" rel="index"><span itemprop="name">caffeine</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/posts/a4ae1aa2/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/a4ae1aa2/" itemprop="commentCount"></span> </a></span><span id="/posts/a4ae1aa2/" class="leancloud_visitors" data-flag-title="Caffeine高性能设计剖析"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数&#58;</span> <span class="leancloud-visitors-count"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">9.1k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">41 分钟</span></div><div class="post-description">Caffeine是一个高性能，高命中率，低内存占用，near optimal的本地缓存，本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><a href="https://github.com/ben-manes/caffeine" rel="external nofollow noopener noreferrer" target="_blank">Caffeine</a>是一个高性能，高命中率，低内存占用，near optimal 的本地缓存，简单来说它是Guava Cache的优化加强版，有些文章把Caffeine称为“新一代的缓存”、“现代缓存之王”。本文将重点讲解Caffeine的高性能设计，以及对应部分的源码分析。</p><h2 id="与Guava-Cache比较"><a href="#与Guava-Cache比较" class="headerlink" title="与Guava Cache比较"></a>与Guava Cache比较</h2><p>如果你对Guava Cache还不理解的话，可以点击<a href="/posts/df42dc84/" title="这里">这里</a>来看一下我之前写过关于Guava Cache的文章。</p><p>大家都知道，Spring5即将放弃掉Guava Cache作为缓存机制，而改用Caffeine作为新的本地Cache的组件，这对于Caffeine来说是一个很大的肯定。为什么Spring会这样做呢？其实在Caffeine的<a href="https://github.com/ben-manes/caffeine/wiki/Benchmarks" rel="external nofollow noopener noreferrer" target="_blank">Benchmarks</a>里给出了好靓仔的数据，对读和写的场景，还有跟其他几个缓存工具进行了比较，Caffeine的性能都表现很突出。</p><p><img src="/images/Caffeine高性能设计剖析__0.png" alt="upload successful"></p><h2 id="使用Caffeine"><a href="#使用Caffeine" class="headerlink" title="使用Caffeine"></a>使用Caffeine</h2><p>Caffeine为了方便大家使用以及从Guava Cache切换过来（很有针对性啊～），借鉴了Guava Cache大部分的概念（诸如核心概念Cache、LoadingCache、CacheLoader、CacheBuilder等等），对于Caffeine的理解只要把它当作Guava Cache就可以了。</p><p>使用上，大家只要把Caffeine的包引进来，然后换一下cache的实现类，基本应该就没问题了。这对与已经使用过Guava Cache的同学来说没有任何难度，甚至还有一点熟悉的味道，如果你之前没有使用过Guava Cache，可以查看Caffeine的<a href="https://github.com/ben-manes/caffeine/wiki" rel="external nofollow noopener noreferrer" target="_blank">官方API说明文档</a>，其中Population，Eviction，Removal，Refresh，Statistics，Cleanup，Policy等等这些特性都是跟Guava Cache基本一样的。</p><p>下面给出一个例子说明怎样创建一个Cache：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">            <span class="comment">//最大个数限制</span></span><br><span class="line">            .maximumSize(<span class="number">256L</span>)</span><br><span class="line">            <span class="comment">//初始化容量</span></span><br><span class="line">            .initialCapacity(<span class="number">1</span>)</span><br><span class="line">            <span class="comment">//访问后过期（包括读和写）</span></span><br><span class="line">            .expireAfterAccess(<span class="number">2</span>, TimeUnit.DAYS)</span><br><span class="line">            <span class="comment">//写后过期</span></span><br><span class="line">            .expireAfterWrite(<span class="number">2</span>, TimeUnit.HOURS)</span><br><span class="line">            <span class="comment">//写后自动异步刷新</span></span><br><span class="line">            .refreshAfterWrite(<span class="number">1</span>, TimeUnit.HOURS)</span><br><span class="line">            <span class="comment">//记录下缓存的一些统计数据，例如命中率等</span></span><br><span class="line">            .recordStats()</span><br><span class="line">            <span class="comment">//cache对缓存写的通知回调</span></span><br><span class="line">            .writer(<span class="keyword">new</span> CacheWriter&lt;Object, Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(@NonNull Object key, @NonNull Object value)</span> </span>&#123;</span><br><span class="line">                    log.info(<span class="string">"key=&#123;&#125;, CacheWriter write"</span>, key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@NonNull Object key, @Nullable Object value, @NonNull RemovalCause cause)</span> </span>&#123;</span><br><span class="line">                    log.info(<span class="string">"key=&#123;&#125;, cause=&#123;&#125;, CacheWriter delete"</span>, key, cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//使用CacheLoader创建一个LoadingCache</span></span><br><span class="line">            .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                <span class="comment">//同步加载数据</span></span><br><span class="line">                <span class="meta">@Nullable</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(@NonNull String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"value_"</span> + key;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//异步加载数据</span></span><br><span class="line">                <span class="meta">@Nullable</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">reload</span><span class="params">(@NonNull String key, @NonNull String oldValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"value_"</span> + key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>更多从Guava Cache迁移过来的使用说明，请看<a href="https://github.com/ben-manes/caffeine/wiki/Guava" rel="external nofollow noopener noreferrer" target="_blank">这里</a></p><h2 id="Caffeine的高性能设计"><a href="#Caffeine的高性能设计" class="headerlink" title="Caffeine的高性能设计"></a>Caffeine的高性能设计</h2><p>判断一个缓存的好坏最核心的指标就是命中率，影响缓存命中率有很多因素，包括业务场景、淘汰策略、清理策略、缓存容量等等。如果作为本地缓存， 它的性能的情况，资源的占用也都是一个很重要的指标。下面</p><p>我们来看看Caffeine在这几个方面是怎么着手的，如何做优化的。</p><p>（注：本文不会分析Caffeine全部源码，只会对核心设计的实现进行分析，但我建议读者把Caffeine的源码都涉猎一下，有个overview才能更好理解本文。如果你看过Guava Cache的源码也行，代码的数据结构和处理逻辑很类似的。</p><p>源码基于：caffeine-2.8.0.jar）</p><h3 id="W-TinyLFU整体设计"><a href="#W-TinyLFU整体设计" class="headerlink" title="W-TinyLFU整体设计"></a>W-TinyLFU整体设计</h3><p>上面说到淘汰策略是影响缓存命中率的因素之一，一般比较简单的缓存就会直接用到LFU(Least Frequently Used，即最不经常使用)或者LRU(Least Recently Used，即最近最少使用)，而Caffeine就是使用了W-TinyLFU算法。</p><p>W-TinyLFU看名字就能大概猜出来，它是LFU的变种，也是一种缓存淘汰算法。那为什么要使用W-TinyLFU呢？</p><h4 id="LRU和LFU的缺点"><a href="#LRU和LFU的缺点" class="headerlink" title="LRU和LFU的缺点"></a>LRU和LFU的缺点</h4><ul><li><p>LRU实现简单，在一般情况下能够表现出很好的命中率，是一个“性价比”很高的算法，平时也很常用。虽然LRU对突发性的稀疏流量（sparse bursts）表现很好，但同时也会产生缓存污染，举例来说，如果偶然性的要对全量数据进行遍历，那么“历史访问记录”就会被刷走，造成污染。</p></li><li><p>如果数据的分布在一段时间内是固定的话，那么LFU可以达到最高的命中率。但是LFU有两个缺点，第一，它需要给每个记录项维护频率信息，每次访问都需要更新，这是个巨大的开销；第二，对突发性的稀疏流量无力，因为前期经常访问的记录已经占用了缓存，偶然的流量不太可能会被保留下来，而且过去的一些大量被访问的记录在将来也不一定会使用上，这样就一直把“坑”占着了。</p></li></ul><p>无论LRU还是LFU都有其各自的缺点，不过，现在已经有很多针对其缺点而改良、优化出来的变种算法。</p><h4 id="TinyLFU"><a href="#TinyLFU" class="headerlink" title="TinyLFU"></a>TinyLFU</h4><p>TinyLFU就是其中一个优化算法，它是专门为了解决LFU上述提到的两个问题而被设计出来的。</p><p>解决第一个问题是采用了Count–Min Sketch算法。</p><p>解决第二个问题是让记录尽量保持相对的“新鲜”（Freshness Mechanism），并且当有新的记录插入时，可以让它跟老的记录进行“PK”，输者就会被淘汰，这样一些老的、不再需要的记录就会被剔除。</p><p>下图是TinyLFU设计图（来自官方）</p><p><img src="/images/Caffeine高性能设计剖析__1.png" alt="upload successful"></p><h5 id="统计频率Count–Min-Sketch算法"><a href="#统计频率Count–Min-Sketch算法" class="headerlink" title="统计频率Count–Min Sketch算法"></a>统计频率Count–Min Sketch算法</h5><p>如何对一个key进行统计，但又可以节省空间呢？（不是简单的使用HashMap，这太消耗内存了），注意哦，不需要精确的统计，只需要一个近似值就可以了，怎么样，这样场景是不是很熟悉，如果你是老司机，或许已经联想到布隆过滤器（Bloom Filter）的应用了。</p><p>没错，将要介绍的Count–Min Sketch的原理跟Bloom Filter一样，只不过Bloom Filter只有0和1的值，那么你可以把Count–Min Sketch看作是“数值”版的Bloom Filter。</p><p>更多关于Count–Min Sketch的介绍请自行搜索。</p><p>在TinyLFU中，近似频率的统计如下图所示：</p><p><img src="/images/Caffeine高性能设计剖析__2.png" alt="upload successful"></p><p>对一个key进行多次hash函数后，index到多个数组位置后进行累加，查询时取多个值中的最小值即可。</p><p>Caffeine对这个算法的实现在<code>FrequencySketch</code>类。但Caffeine对此有进一步的优化，例如Count–Min Sketch使用了二维数组，Caffeine只是用了一个一维的数组；再者，如果是数值类型的话，这个数需要用int或long来存储，但是Caffeine认为缓存的访问频率不需要用到那么大，只需要15就足够，一般认为达到15次的频率算是很高的了，而且Caffeine还有另外一个机制来使得这个频率进行衰退减半（下面就会讲到）。如果最大是15的话，那么只需要4个bit就可以满足了，一个long有64bit，可以存储16个这样的统计数，Caffeine就是这样的设计，使得存储效率提高了16倍。</p><p>Caffeine对缓存的读写（<code>afterRead</code>和<code>afterWrite</code>方法）都会调用<code>onAccess</code>s方法，而onAccess方法里有一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frequencySketch().increment(key);</span><br></pre></td></tr></table></figure><p>这句就是追加记录的频率，下面我们看看具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//FrequencySketch的一些属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//种子数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>[] SEED = &#123; <span class="comment">// A mixture of seeds from FNV-1a, CityHash, and Murmur3</span></span><br><span class="line">    <span class="number">0xc3a5c85c97cb3127L</span>, <span class="number">0xb492b66fbe98f273L</span>, <span class="number">0x9ae16a3b2f90404fL</span>, <span class="number">0xcbf29ce484222325L</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RESET_MASK = <span class="number">0x7777777777777777L</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ONE_MASK = <span class="number">0x1111111111111111L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sampleSize;</span><br><span class="line"><span class="comment">//为了快速根据hash值得到table的index值的掩码</span></span><br><span class="line"><span class="comment">//table的长度size一般为2的n次方，而tableMask为size-1，这样就可以通过&amp;操作来模拟取余操作，速度快很多，老司机都知道</span></span><br><span class="line"><span class="keyword">int</span> tableMask;</span><br><span class="line"><span class="comment">//存储数据的一维long数组</span></span><br><span class="line"><span class="keyword">long</span>[] table;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increments the popularity of the element if it does not exceed the maximum (15). The popularity</span></span><br><span class="line"><span class="comment"> * of all elements will be periodically down sampled when the observed events exceeds a threshold.</span></span><br><span class="line"><span class="comment"> * This process provides a frequency aging to allow expired long term entries to fade away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(@NonNull E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotInitialized()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据key的hashCode通过一个哈希函数得到一个hash值</span></span><br><span class="line">  <span class="comment">//本来就是hashCode了，为什么还要再做一次hash？怕原来的hashCode不够均匀分散，再打散一下。</span></span><br><span class="line">  <span class="keyword">int</span> hash = spread(e.hashCode());</span><br><span class="line">  <span class="comment">//这句光看有点难理解</span></span><br><span class="line">  <span class="comment">//就如我刚才说的，Caffeine把一个long的64bit划分成16个等分，每一等分4个bit。</span></span><br><span class="line">  <span class="comment">//这个start就是用来定位到是哪一个等分的，用hash值低两位作为随机数，再左移2位，得到一个小于16的值</span></span><br><span class="line">  <span class="keyword">int</span> start = (hash &amp; <span class="number">3</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//indexOf方法的意思就是，根据hash值和不同种子得到table的下标index</span></span><br><span class="line">  <span class="comment">//这里通过四个不同的种子，得到四个不同的下标index</span></span><br><span class="line">  <span class="keyword">int</span> index0 = indexOf(hash, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> index1 = indexOf(hash, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> index2 = indexOf(hash, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> index3 = indexOf(hash, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据index和start(+1, +2, +3)的值，把table[index]对应的等分追加1</span></span><br><span class="line">  <span class="comment">//这个incrementAt方法有点难理解，看我下面的解释</span></span><br><span class="line">  <span class="keyword">boolean</span> added = incrementAt(index0, start);</span><br><span class="line">  added |= incrementAt(index1, start + <span class="number">1</span>);</span><br><span class="line">  added |= incrementAt(index2, start + <span class="number">2</span>);</span><br><span class="line">  added |= incrementAt(index3, start + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个reset等下说</span></span><br><span class="line">  <span class="keyword">if</span> (added &amp;&amp; (++size == sampleSize)) &#123;</span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increments the specified counter by 1 if it is not already at the maximum value (15).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the table index (16 counters)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j the counter to increment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> if incremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">incrementAt</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这个j表示16个等分的下标，那么offset就是相当于在64位中的下标（这个自己想想）</span></span><br><span class="line">  <span class="keyword">int</span> offset = j &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//上面提到Caffeine把频率统计最大定为15，即0xfL</span></span><br><span class="line">  <span class="comment">//mask就是在64位中的掩码，即1111后面跟很多个0</span></span><br><span class="line">  <span class="keyword">long</span> mask = (<span class="number">0xfL</span> &lt;&lt; offset);</span><br><span class="line">  <span class="comment">//如果&amp;的结果不等于15，那么就追加1。等于15就不会再加了</span></span><br><span class="line">  <span class="keyword">if</span> ((table[i] &amp; mask) != mask) &#123;</span><br><span class="line">    table[i] += (<span class="number">1L</span> &lt;&lt; offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the table index for the counter at the specified depth.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item the element's hash</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the counter depth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> item, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> hash = SEED[i] * item;</span><br><span class="line">  hash += hash &gt;&gt;&gt; <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">int</span>) hash) &amp; tableMask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Applies a supplemental hash function to a given hashCode, which defends against poor quality</span></span><br><span class="line"><span class="comment"> * hash functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  x = ((x &gt;&gt;&gt; <span class="number">16</span>) ^ x) * <span class="number">0x45d9f3b</span>;</span><br><span class="line">  x = ((x &gt;&gt;&gt; <span class="number">16</span>) ^ x) * <span class="number">0x45d9f3b</span>;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt;&gt; <span class="number">16</span>) ^ x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了追加方法，那么读取方法<code>frequency</code>就很容易理解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the estimated number of occurrences of an element, up to the maximum (15).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to count occurrences of</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the estimated number of occurrences of the element; possibly zero but never negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNegative</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frequency</span><span class="params">(@NonNull E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotInitialized()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//得到hash值，跟上面一样</span></span><br><span class="line">  <span class="keyword">int</span> hash = spread(e.hashCode());</span><br><span class="line">  <span class="comment">//得到等分的下标，跟上面一样</span></span><br><span class="line">  <span class="keyword">int</span> start = (hash &amp; <span class="number">3</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> frequency = Integer.MAX_VALUE;</span><br><span class="line">  <span class="comment">//循环四次，分别获取在table数组中不同的下标位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = indexOf(hash, i);</span><br><span class="line">    <span class="comment">//这个操作就不多说了，其实跟上面incrementAt是一样的，定位到table[index] + 等分的位置，再根据mask取出计数值</span></span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>) ((table[index] &gt;&gt;&gt; ((start + i) &lt;&lt; <span class="number">2</span>)) &amp; <span class="number">0xfL</span>);</span><br><span class="line">    <span class="comment">//取四个中的较小值</span></span><br><span class="line">    frequency = Math.min(frequency, count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> frequency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码和注释或者读者可能难以理解，下图是我画出来帮助大家理解的结构图。</p><p>注意紫色虚线框，其中蓝色小格就是需要计算的位置：</p><p><img src="/images/Caffeine高性能设计剖析__3.png" alt="upload successful"></p><h5 id="保新机制"><a href="#保新机制" class="headerlink" title="保新机制"></a>保新机制</h5><p>为了让缓存保持“新鲜”，剔除掉过往频率很高但之后不经常的缓存，Caffeine有一个Freshness Mechanism。做法很简答，就是当整体的统计计数（当前所有记录的频率统计之和，这个数值内部维护）达到某一个值时，那么所有记录的频率统计除以2。</p><p>从上面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size变量就是所有记录的频率统计之，即每个记录加1，这个size都会加1</span></span><br><span class="line"><span class="comment">//sampleSize一个阈值，从FrequencySketch初始化可以看到它的值为maximumSize的10倍</span></span><br><span class="line"><span class="keyword">if</span> (added &amp;&amp; (++size == sampleSize)) &#123;</span><br><span class="line">      reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到<code>reset</code>方法就是做这个事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Reduces every counter by half of its original value. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">    count += Long.bitCount(table[i] &amp; ONE_MASK);</span><br><span class="line">    table[i] = (table[i] &gt;&gt;&gt; <span class="number">1</span>) &amp; RESET_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  size = (size &gt;&gt;&gt; <span class="number">1</span>) - (count &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个reset方法，为什么是除以2，而不是其他，及其正确性，在最下面的参考资料的TinyLFU论文中3.3章节给出了数学证明，大家有兴趣可以看看。</p><h4 id="增加一个Window？"><a href="#增加一个Window？" class="headerlink" title="增加一个Window？"></a>增加一个Window？</h4><p>Caffeine通过测试发现TinyLFU在面对突发性的稀疏流量（sparse bursts）时表现很差，因为新的记录（new items）还没来得及建立足够的频率就被剔除出去了，这就使得命中率下降。</p><p>于是Caffeine设计出一种新的policy，即Window Tiny LFU（W-TinyLFU），并通过实验和实践发现W-TinyLFU比TinyLFU表现的更好。</p><p>W-TinyLFU的设计如下所示（两图等价）：</p><p><img src="/images/Caffeine高性能设计剖析__4.png" alt="upload successful"></p><p><img src="/images/Caffeine高性能设计剖析__5.png" alt="upload successful"></p><p>它主要包括两个缓存模块，主缓存是SLRU（Segmented LRU，即分段LRU），SLRU包括一个名为protected和一个名为probation的缓存区。通过增加一个缓存区（即Window Cache），当有新的记录插入时，会先在window区呆一下，就可以避免上述说的sparse bursts问题。</p><h4 id="淘汰策略（eviction-policy）"><a href="#淘汰策略（eviction-policy）" class="headerlink" title="淘汰策略（eviction policy）"></a>淘汰策略（eviction policy）</h4><p>当window区满了，就会根据LRU把candidate（即淘汰出来的元素）放到probation区，如果probation区也满了，就把candidate和probation将要淘汰的元素victim，两个进行“PK”，胜者留在probation，输者就要被淘汰了。</p><p>而且经过实验发现当window区配置为总容量的1%，剩余的99%当中的80%分给protected区，20%分给probation区时，这时整体性能和命中率表现得最好，所以Caffeine默认的比例设置就是这个。</p><p>不过这个比例Caffeine会在运行时根据统计数据（statistics）去动态调整，如果你的应用程序的缓存随着时间变化比较快的话，那么增加window区的比例可以提高命中率，相反缓存都是比较固定不变的话，增加Main Cache区（protected区 +probation区）的比例会有较好的效果。</p><p>下面我们看看上面说到的淘汰策略是怎么实现的：</p><p>一般缓存对读写操作后都有后续的一系列“维护”操作，Caffeine也不例外，这些操作都在<code>maintenance</code>方法，我们将要说到的淘汰策略也在里面。</p><p>这方法比较重要，下面也会提到，所以这里只先说跟“淘汰策略”有关的<code>evictEntries</code>和<code>climb</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Performs the pending maintenance work and sets the state flags during processing to avoid</span></span><br><span class="line"><span class="comment">   * excess scheduling attempts. The read buffer, write buffer, and reference queues are</span></span><br><span class="line"><span class="comment">   * drained, followed by expiration, and size-based eviction.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task an additional pending task to run, or &#123;<span class="doctag">@code</span> null&#125; if not present</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">maintenance</span><span class="params">(@Nullable Runnable task)</span> </span>&#123;</span><br><span class="line">    lazySetDrainStatus(PROCESSING_TO_IDLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      drainReadBuffer();</span><br><span class="line"></span><br><span class="line">      drainWriteBuffer();</span><br><span class="line">      <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        task.run();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      drainKeyReferences();</span><br><span class="line">      drainValueReferences();</span><br><span class="line"></span><br><span class="line">      expireEntries();</span><br><span class="line">      <span class="comment">//把符合条件的记录淘汰掉</span></span><br><span class="line">      evictEntries();</span><br><span class="line">      <span class="comment">//动态调整window区和protected区的大小</span></span><br><span class="line">      climb();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((drainStatus() != PROCESSING_TO_IDLE) || !casDrainStatus(PROCESSING_TO_IDLE, IDLE)) &#123;</span><br><span class="line">        lazySetDrainStatus(REQUIRED);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>先说一下Caffeine对上面说到的W-TinyLFU策略的实现用到的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大的个数限制</span></span><br><span class="line"><span class="keyword">long</span> maximum;</span><br><span class="line"><span class="comment">//当前的个数</span></span><br><span class="line"><span class="keyword">long</span> weightedSize;</span><br><span class="line"><span class="comment">//window区的最大限制</span></span><br><span class="line"><span class="keyword">long</span> windowMaximum;</span><br><span class="line"><span class="comment">//window区当前的个数</span></span><br><span class="line"><span class="keyword">long</span> windowWeightedSize;</span><br><span class="line"><span class="comment">//protected区的最大限制</span></span><br><span class="line"><span class="keyword">long</span> mainProtectedMaximum;</span><br><span class="line"><span class="comment">//protected区当前的个数</span></span><br><span class="line"><span class="keyword">long</span> mainProtectedWeightedSize;</span><br><span class="line"><span class="comment">//下一次需要调整的大小（还需要进一步计算）</span></span><br><span class="line"><span class="keyword">double</span> stepSize;</span><br><span class="line"><span class="comment">//window区需要调整的大小</span></span><br><span class="line"><span class="keyword">long</span> adjustment;</span><br><span class="line"><span class="comment">//命中计数</span></span><br><span class="line"><span class="keyword">int</span> hitsInSample;</span><br><span class="line"><span class="comment">//不命中的计数</span></span><br><span class="line"><span class="keyword">int</span> missesInSample;</span><br><span class="line"><span class="comment">//上一次的缓存命中率</span></span><br><span class="line"><span class="keyword">double</span> previousSampleHitRate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> FrequencySketch&lt;K&gt; sketch;</span><br><span class="line"><span class="comment">//window区的LRU queue（FIFO）</span></span><br><span class="line"><span class="keyword">final</span> AccessOrderDeque&lt;Node&lt;K, V&gt;&gt; accessOrderWindowDeque;</span><br><span class="line"><span class="comment">//probation区的LRU queue（FIFO）</span></span><br><span class="line"><span class="keyword">final</span> AccessOrderDeque&lt;Node&lt;K, V&gt;&gt; accessOrderProbationDeque;</span><br><span class="line"><span class="comment">//protected区的LRU queue（FIFO）</span></span><br><span class="line"><span class="keyword">final</span> AccessOrderDeque&lt;Node&lt;K, V&gt;&gt; accessOrderProtectedDeque;</span><br></pre></td></tr></table></figure><p>以及默认比例设置（意思看注释）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The initial percent of the maximum weighted capacity dedicated to the main space. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PERCENT_MAIN = <span class="number">0.99</span>d;</span><br><span class="line"><span class="comment">/** The percent of the maximum weighted capacity dedicated to the main's protected space. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PERCENT_MAIN_PROTECTED = <span class="number">0.80</span>d;</span><br><span class="line"><span class="comment">/** The difference in hit rates that restarts the climber. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> HILL_CLIMBER_RESTART_THRESHOLD = <span class="number">0.05</span>d;</span><br><span class="line"><span class="comment">/** The percent of the total size to adapt the window by. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> HILL_CLIMBER_STEP_PERCENT = <span class="number">0.0625</span>d;</span><br><span class="line"><span class="comment">/** The rate to decrease the step size to adapt by. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> HILL_CLIMBER_STEP_DECAY_RATE = <span class="number">0.98</span>d;</span><br><span class="line"><span class="comment">/** The maximum number of entries that can be transfered between queues. */</span></span><br></pre></td></tr></table></figure><p>重点来了，evictEntries和climb方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Evicts entries if the cache exceeds the maximum. */</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!evicts()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//淘汰window区的记录</span></span><br><span class="line">  <span class="keyword">int</span> candidates = evictFromWindow();</span><br><span class="line">  <span class="comment">//淘汰Main区的记录</span></span><br><span class="line">  evictFromMain(candidates);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evicts entries from the window space into the main space while the window size exceeds a</span></span><br><span class="line"><span class="comment"> * maximum.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of candidate entries evicted from the window space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据W-TinyLFU，新的数据都会无条件的加到admission window</span></span><br><span class="line"><span class="comment">//但是window是有大小限制，所以要“定期”做一下“维护”</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evictFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> candidates = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//查看window queue的头部节点</span></span><br><span class="line">  Node&lt;K, V&gt; node = accessOrderWindowDeque().peek();</span><br><span class="line">  <span class="comment">//如果window区超过了最大的限制，那么就要把“多出来”的记录做处理</span></span><br><span class="line">  <span class="keyword">while</span> (windowWeightedSize() &gt; windowMaximum()) &#123;</span><br><span class="line">    <span class="comment">// The pending operations will adjust the size to reflect the correct weight</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;K, V&gt; next = node.getNextInAccessOrder();</span><br><span class="line">    <span class="keyword">if</span> (node.getWeight() != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//把node定位在probation区</span></span><br><span class="line">      node.makeMainProbation();</span><br><span class="line">      <span class="comment">//从window区去掉</span></span><br><span class="line">      accessOrderWindowDeque().remove(node);</span><br><span class="line">      <span class="comment">//加入到probation queue，相当于把节点移动到probation区（晋升了）</span></span><br><span class="line">      accessOrderProbationDeque().add(node);</span><br><span class="line">      candidates++;</span><br><span class="line">      <span class="comment">//因为移除了一个节点，所以需要调整window的size</span></span><br><span class="line">      setWindowWeightedSize(windowWeightedSize() - node.getPolicyWeight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理下一个节点</span></span><br><span class="line">    node = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>evictFromMain</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evicts entries from the main space if the cache exceeds the maximum capacity. The main space</span></span><br><span class="line"><span class="comment"> * determines whether admitting an entry (coming from the window space) is preferable to retaining</span></span><br><span class="line"><span class="comment"> * the eviction policy's victim. This is decision is made using a frequency filter so that the</span></span><br><span class="line"><span class="comment"> * least frequently used entry is removed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The window space candidates were previously placed in the MRU position and the eviction</span></span><br><span class="line"><span class="comment"> * policy's victim is at the LRU position. The two ends of the queue are evaluated while an</span></span><br><span class="line"><span class="comment"> * eviction is required. The number of remaining candidates is provided and decremented on</span></span><br><span class="line"><span class="comment"> * eviction, so that when there are no more candidates the victim is evicted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidates the number of candidate entries evicted from the window space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据W-TinyLFU，从window晋升过来的要跟probation区的进行“PK”，胜者才能留下</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictFromMain</span><span class="params">(<span class="keyword">int</span> candidates)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> victimQueue = PROBATION;</span><br><span class="line">  <span class="comment">//victim是probation queue的头部</span></span><br><span class="line">  Node&lt;K, V&gt; victim = accessOrderProbationDeque().peekFirst();</span><br><span class="line">  <span class="comment">//candidate是probation queue的尾部，也就是刚从window晋升来的</span></span><br><span class="line">  Node&lt;K, V&gt; candidate = accessOrderProbationDeque().peekLast();</span><br><span class="line">  <span class="comment">//当cache不够容量时才做处理</span></span><br><span class="line">  <span class="keyword">while</span> (weightedSize() &gt; maximum()) &#123;</span><br><span class="line">    <span class="comment">// Stop trying to evict candidates and always prefer the victim</span></span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="number">0</span>) &#123;</span><br><span class="line">      candidate = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对candidate为null且victim为bull的处理</span></span><br><span class="line">    <span class="keyword">if</span> ((candidate == <span class="keyword">null</span>) &amp;&amp; (victim == <span class="keyword">null</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (victimQueue == PROBATION) &#123;</span><br><span class="line">        victim = accessOrderProtectedDeque().peekFirst();</span><br><span class="line">        victimQueue = PROTECTED;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (victimQueue == PROTECTED) &#123;</span><br><span class="line">        victim = accessOrderWindowDeque().peekFirst();</span><br><span class="line">        victimQueue = WINDOW;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The pending operations will adjust the size to reflect the correct weight</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对节点的weight为0的处理</span></span><br><span class="line">    <span class="keyword">if</span> ((victim != <span class="keyword">null</span>) &amp;&amp; (victim.getPolicyWeight() == <span class="number">0</span>)) &#123;</span><br><span class="line">      victim = victim.getNextInAccessOrder();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((candidate != <span class="keyword">null</span>) &amp;&amp; (candidate.getPolicyWeight() == <span class="number">0</span>)) &#123;</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">      candidates--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Evict immediately if only one of the entries is present</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"NullAway"</span>)</span><br><span class="line">      Node&lt;K, V&gt; previous = candidate.getPreviousInAccessOrder();</span><br><span class="line">      Node&lt;K, V&gt; evict = candidate;</span><br><span class="line">      candidate = previous;</span><br><span class="line">      candidates--;</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Node&lt;K, V&gt; evict = victim;</span><br><span class="line">      victim = victim.getNextInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Evict immediately if an entry was collected</span></span><br><span class="line">    K victimKey = victim.getKey();</span><br><span class="line">    K candidateKey = candidate.getKey();</span><br><span class="line">    <span class="keyword">if</span> (victimKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@NonNull</span> Node&lt;K, V&gt; evict = victim;</span><br><span class="line">      victim = victim.getNextInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.COLLECTED, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">      candidates--;</span><br><span class="line">      <span class="meta">@NonNull</span> Node&lt;K, V&gt; evict = candidate;</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.COLLECTED, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放不下的节点直接处理掉</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.getPolicyWeight() &gt; maximum()) &#123;</span><br><span class="line">      candidates--;</span><br><span class="line">      Node&lt;K, V&gt; evict = candidate;</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据节点的统计频率frequency来做比较，看看要处理掉victim还是candidate</span></span><br><span class="line">    <span class="comment">//admit是具体的比较规则，看下面</span></span><br><span class="line">    candidates--;</span><br><span class="line">    <span class="comment">//如果candidate胜出则淘汰victim</span></span><br><span class="line">    <span class="keyword">if</span> (admit(candidateKey, victimKey)) &#123;</span><br><span class="line">      Node&lt;K, V&gt; evict = victim;</span><br><span class="line">      victim = victim.getNextInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果是victim胜出，则淘汰candidate</span></span><br><span class="line">      Node&lt;K, V&gt; evict = candidate;</span><br><span class="line">      candidate = candidate.getPreviousInAccessOrder();</span><br><span class="line">      evictEntry(evict, RemovalCause.SIZE, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determines if the candidate should be accepted into the main space, as determined by its</span></span><br><span class="line"><span class="comment"> * frequency relative to the victim. A small amount of randomness is used to protect against hash</span></span><br><span class="line"><span class="comment"> * collision attacks, where the victim's frequency is artificially raised so that no new entries</span></span><br><span class="line"><span class="comment"> * are admitted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidateKey the key for the entry being proposed for long term retention</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> victimKey the key for the entry chosen by the eviction policy for replacement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> if the candidate should be admitted and the victim ejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">admit</span><span class="params">(K candidateKey, K victimKey)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分别获取victim和candidate的统计频率</span></span><br><span class="line">  <span class="comment">//frequency这个方法的原理和实现上面已经解释了</span></span><br><span class="line">  <span class="keyword">int</span> victimFreq = frequencySketch().frequency(victimKey);</span><br><span class="line">  <span class="keyword">int</span> candidateFreq = frequencySketch().frequency(candidateKey);</span><br><span class="line">  <span class="comment">//谁大谁赢</span></span><br><span class="line">  <span class="keyword">if</span> (candidateFreq &gt; victimFreq) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果相等，candidate小于5都当输了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateFreq &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// The maximum frequency is 15 and halved to 7 after a reset to age the history. An attack</span></span><br><span class="line">    <span class="comment">// exploits that a hot candidate is rejected in favor of a hot victim. The threshold of a warm</span></span><br><span class="line">    <span class="comment">// candidate reduces the number of random acceptances to minimize the impact on the hit rate.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果相等且candidate大于5，则随机淘汰一个</span></span><br><span class="line">  <span class="keyword">int</span> random = ThreadLocalRandom.current().nextInt();</span><br><span class="line">  <span class="keyword">return</span> ((random &amp; <span class="number">127</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>climb</code>方法主要是用来调整window size的，使得Caffeine可以适应你的应用类型（如OLAP或OLTP）表现出最佳的命中率。</p><p>下图是官方测试的数据：</p><p><img src="/images/Caffeine高性能设计剖析__6.png" alt="upload successful"></p><p>我们看看window size的调整是怎么实现的。</p><p>调整时用到的默认比例数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与上次命中率之差的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> HILL_CLIMBER_RESTART_THRESHOLD = <span class="number">0.05</span>d;</span><br><span class="line"><span class="comment">//步长（调整）的大小（跟最大值maximum的比例）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> HILL_CLIMBER_STEP_PERCENT = <span class="number">0.0625</span>d;</span><br><span class="line"><span class="comment">//步长的衰减比例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> HILL_CLIMBER_STEP_DECAY_RATE = <span class="number">0.98</span>d;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** Adapts the eviction policy to towards the optimal recency / frequency configuration. */</span></span><br><span class="line"><span class="comment">//climb方法的主要作用就是动态调整window区的大小（相应的，main区的大小也会发生变化，两个之和为100%）。</span></span><br><span class="line"><span class="comment">//因为区域的大小发生了变化，那么区域内的数据也可能需要发生相应的移动。</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">climb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!evicts()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确定window需要调整的大小</span></span><br><span class="line">  determineAdjustment();</span><br><span class="line">  <span class="comment">//如果protected区有溢出，把溢出部分移动到probation区。因为下面的操作有可能需要调整到protected区。</span></span><br><span class="line">  demoteFromMainProtected();</span><br><span class="line">  <span class="keyword">long</span> amount = adjustment();</span><br><span class="line">  <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//增加window的大小</span></span><br><span class="line">    increaseWindow();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//减少window的大小</span></span><br><span class="line">    decreaseWindow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分别展开每个方法来解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Calculates the amount to adapt the window by and sets &#123;<span class="doctag">@link</span> #adjustment()&#125; accordingly. */</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">determineAdjustment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果frequencySketch还没初始化，则返回</span></span><br><span class="line">  <span class="keyword">if</span> (frequencySketch().isNotInitialized()) &#123;</span><br><span class="line">    setPreviousSampleHitRate(<span class="number">0.0</span>);</span><br><span class="line">    setMissesInSample(<span class="number">0</span>);</span><br><span class="line">    setHitsInSample(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//总请求量 = 命中 + miss</span></span><br><span class="line">  <span class="keyword">int</span> requestCount = hitsInSample() + missesInSample();</span><br><span class="line">  <span class="comment">//没达到sampleSize则返回</span></span><br><span class="line">  <span class="comment">//默认下sampleSize = 10 * maximum。用sampleSize来判断缓存是否足够”热“。</span></span><br><span class="line">  <span class="keyword">if</span> (requestCount &lt; frequencySketch().sampleSize) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//命中率的公式 = 命中 / 总请求</span></span><br><span class="line">  <span class="keyword">double</span> hitRate = (<span class="keyword">double</span>) hitsInSample() / requestCount;</span><br><span class="line">  <span class="comment">//命中率的差值</span></span><br><span class="line">  <span class="keyword">double</span> hitRateChange = hitRate - previousSampleHitRate();</span><br><span class="line">  <span class="comment">//本次调整的大小，是由命中率的差值和上次的stepSize决定的</span></span><br><span class="line">  <span class="keyword">double</span> amount = (hitRateChange &gt;= <span class="number">0</span>) ? stepSize() : -stepSize();</span><br><span class="line">  <span class="comment">//下次的调整大小：如果命中率的之差大于0.05，则重置为0.065 * maximum，否则按照0.98来进行衰减</span></span><br><span class="line">  <span class="keyword">double</span> nextStepSize = (Math.abs(hitRateChange) &gt;= HILL_CLIMBER_RESTART_THRESHOLD)</span><br><span class="line">      ? HILL_CLIMBER_STEP_PERCENT * maximum() * (amount &gt;= <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>)</span><br><span class="line">      : HILL_CLIMBER_STEP_DECAY_RATE * amount;</span><br><span class="line">  setPreviousSampleHitRate(hitRate);</span><br><span class="line">  setAdjustment((<span class="keyword">long</span>) amount);</span><br><span class="line">  setStepSize(nextStepSize);</span><br><span class="line">  setMissesInSample(<span class="number">0</span>);</span><br><span class="line">  setHitsInSample(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Transfers the nodes from the protected to the probation region if it exceeds the maximum. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法比较简单，减少protected区溢出的部分</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demoteFromMainProtected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> mainProtectedMaximum = mainProtectedMaximum();</span><br><span class="line">  <span class="keyword">long</span> mainProtectedWeightedSize = mainProtectedWeightedSize();</span><br><span class="line">  <span class="keyword">if</span> (mainProtectedWeightedSize &lt;= mainProtectedMaximum) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QUEUE_TRANSFER_THRESHOLD; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mainProtectedWeightedSize &lt;= mainProtectedMaximum) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; demoted = accessOrderProtectedDeque().poll();</span><br><span class="line">    <span class="keyword">if</span> (demoted == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demoted.makeMainProbation();</span><br><span class="line">    accessOrderProbationDeque().add(demoted);</span><br><span class="line">    mainProtectedWeightedSize -= demoted.getPolicyWeight();</span><br><span class="line">  &#125;</span><br><span class="line">  setMainProtectedWeightedSize(mainProtectedWeightedSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the size of the admission window by shrinking the portion allocated to the main</span></span><br><span class="line"><span class="comment"> * space. As the main space is partitioned into probation and protected regions (80% / 20%), for</span></span><br><span class="line"><span class="comment"> * simplicity only the protected is reduced. If the regions exceed their maximums, this may cause</span></span><br><span class="line"><span class="comment"> * protected items to be demoted to the probation region and probation items to be demoted to the</span></span><br><span class="line"><span class="comment"> * admission window.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加window区的大小，这个方法比较简单，思路就像我上面说的</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mainProtectedMaximum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> quota = Math.min(adjustment(), mainProtectedMaximum());</span><br><span class="line">  setMainProtectedMaximum(mainProtectedMaximum() - quota);</span><br><span class="line">  setWindowMaximum(windowMaximum() + quota);</span><br><span class="line">  demoteFromMainProtected();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QUEUE_TRANSFER_THRESHOLD; i++) &#123;</span><br><span class="line">    Node&lt;K, V&gt; candidate = accessOrderProbationDeque().peek();</span><br><span class="line">    <span class="keyword">boolean</span> probation = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((candidate == <span class="keyword">null</span>) || (quota &lt; candidate.getPolicyWeight())) &#123;</span><br><span class="line">      candidate = accessOrderProtectedDeque().peek();</span><br><span class="line">      probation = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> weight = candidate.getPolicyWeight();</span><br><span class="line">    <span class="keyword">if</span> (quota &lt; weight) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quota -= weight;</span><br><span class="line">    <span class="keyword">if</span> (probation) &#123;</span><br><span class="line">      accessOrderProbationDeque().remove(candidate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setMainProtectedWeightedSize(mainProtectedWeightedSize() - weight);</span><br><span class="line">      accessOrderProtectedDeque().remove(candidate);</span><br><span class="line">    &#125;</span><br><span class="line">    setWindowWeightedSize(windowWeightedSize() + weight);</span><br><span class="line">    accessOrderWindowDeque().add(candidate);</span><br><span class="line">    candidate.makeWindow();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMainProtectedMaximum(mainProtectedMaximum() + quota);</span><br><span class="line">  setWindowMaximum(windowMaximum() - quota);</span><br><span class="line">  setAdjustment(quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Decreases the size of the admission window and increases the main's protected region. */</span></span><br><span class="line"><span class="comment">//同上increaseWindow差不多，反操作</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"evictionLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decreaseWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (windowMaximum() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> quota = Math.min(-adjustment(), Math.max(<span class="number">0</span>, windowMaximum() - <span class="number">1</span>));</span><br><span class="line">  setMainProtectedMaximum(mainProtectedMaximum() + quota);</span><br><span class="line">  setWindowMaximum(windowMaximum() - quota);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QUEUE_TRANSFER_THRESHOLD; i++) &#123;</span><br><span class="line">    Node&lt;K, V&gt; candidate = accessOrderWindowDeque().peek();</span><br><span class="line">    <span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> weight = candidate.getPolicyWeight();</span><br><span class="line">    <span class="keyword">if</span> (quota &lt; weight) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quota -= weight;</span><br><span class="line">    setMainProtectedWeightedSize(mainProtectedWeightedSize() + weight);</span><br><span class="line">    setWindowWeightedSize(windowWeightedSize() - weight);</span><br><span class="line">    accessOrderWindowDeque().remove(candidate);</span><br><span class="line">    accessOrderProbationDeque().add(candidate);</span><br><span class="line">    candidate.makeMainProbation();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMainProtectedMaximum(mainProtectedMaximum() - quota);</span><br><span class="line">  setWindowMaximum(windowMaximum() + quota);</span><br><span class="line">  setAdjustment(-quota);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，是Caffeine的W-TinyLFU策略的设计原理及代码实现解析。</p><h3 id="异步的高性能读写"><a href="#异步的高性能读写" class="headerlink" title="异步的高性能读写"></a>异步的高性能读写</h3><p>一般的缓存每次对数据处理完之后（读的话，已经存在则直接返回，不存在则load数据，保存，再返回；写的话，则直接插入或更新），但是因为要维护一些淘汰策略，则需要一些额外的操作，诸如：</p><ul><li>计算和比较数据的是否过期</li><li>统计频率（像LFU或其变种）</li><li>维护read queue和write queue</li><li>淘汰符合条件的数据</li><li>等等。。。</li></ul><p>这种数据的读写伴随着缓存状态的变更，Guava Cache的做法是把这些操作和读写操作放在一起，在一个同步加锁的操作中完成，虽然Guava Cache巧妙地利用了JDK的ConcurrentHashMap（分段锁或者无锁CAS）来降低锁的密度，达到提高并发度的目的。但是，对于一些热点数据，这种做法还是避免不了频繁的锁竞争。Caffeine借鉴了数据库系统的WAL（Write-Ahead Logging）思想，即先写日志再执行操作，这种思想同样适合缓存的，执行读写操作时，先把操作记录在缓冲区，然后在合适的时机异步、批量地执行缓冲区中的内容。但在执行缓冲区的内容时，也是需要在缓冲区加上同步锁的，不然存在并发问题，只不过这样就可以把对锁的竞争从缓存数据转移到对缓冲区上。</p><h4 id="ReadBuffer"><a href="#ReadBuffer" class="headerlink" title="ReadBuffer"></a>ReadBuffer</h4><p>在Caffeine的内部实现中，为了很好的支持不同的Features（如Eviction，Removal，Refresh，Statistics，Cleanup，Policy等等），扩展了很多子类，它们共同的父类是<code>BoundedLocalCache</code>，而<code>readBuffer</code>就是作为它们共有的属性，即都是用一样的readBuffer，看定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Buffer&lt;Node&lt;K, V&gt;&gt; readBuffer;</span><br><span class="line"></span><br><span class="line">readBuffer = evicts() || collectKeys() || collectValues() || expiresAfterAccess()</span><br><span class="line">        ? <span class="keyword">new</span> BoundedBuffer&lt;&gt;()</span><br><span class="line">        : Buffer.disabled();</span><br></pre></td></tr></table></figure><p>上面提到Caffeine对每次缓存的读操作都会触发<code>afterRead</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs the post-processing work required after a read.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the entry in the page replacement policy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now the current time, in nanoseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recordHit if the hit count should be incremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterRead</span><span class="params">(Node&lt;K, V&gt; node, <span class="keyword">long</span> now, <span class="keyword">boolean</span> recordHit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (recordHit) &#123;</span><br><span class="line">    statsCounter().recordHits(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把记录加入到readBuffer</span></span><br><span class="line">  <span class="comment">//判断是否需要立即处理readBuffer</span></span><br><span class="line">  <span class="comment">//注意这里无论offer是否成功都可以走下去的，即允许写入readBuffer丢失，因为这个</span></span><br><span class="line">  <span class="keyword">boolean</span> delayable = skipReadBuffer() || (readBuffer.offer(node) != Buffer.FULL);</span><br><span class="line">  <span class="keyword">if</span> (shouldDrainBuffers(delayable)) &#123;</span><br><span class="line">    scheduleDrainBuffers();</span><br><span class="line">  &#125;</span><br><span class="line">  refreshIfNeeded(node, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns whether maintenance work is needed.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> delayable if draining the read buffer can be delayed</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//caffeine用了一组状态来定义和管理“维护”的过程</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">shouldDrainBuffers</span><span class="params">(<span class="keyword">boolean</span> delayable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (drainStatus()) &#123;</span><br><span class="line">      <span class="keyword">case</span> IDLE:</span><br><span class="line">        <span class="keyword">return</span> !delayable;</span><br><span class="line">      <span class="keyword">case</span> REQUIRED:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">case</span> PROCESSING_TO_IDLE:</span><br><span class="line">      <span class="keyword">case</span> PROCESSING_TO_REQUIRED:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重点看<code>BoundedBuffer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A striped, non-blocking, bounded buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ben.manes@gmail.com (Ben Manes)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; the type of elements maintained by this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">StripedBuffer</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它是一个striped、非阻塞、有界限的buffer，继承于<code>StripedBuffer</code>类。下面看看StripedBuffer的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A base class providing the mechanics for supporting dynamic striping of bounded buffers. This</span></span><br><span class="line"><span class="comment"> * implementation is an adaption of the numeric 64-bit &#123;<span class="doctag">@link</span> java.util.concurrent.atomic.Striped64&#125;</span></span><br><span class="line"><span class="comment"> * class, which is used by atomic counters. The approach was modified to lazily grow an array of</span></span><br><span class="line"><span class="comment"> * buffers in order to minimize memory usage for caches that are not heavily contended on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dl@cs.oswego.edu (Doug Lea)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ben.manes@gmail.com (Ben Manes)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StripedBuffer</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Buffer</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个StripedBuffer设计的思想是跟<code>Striped64</code>类似的，通过扩展结构把竞争热点分离。</p><p>具体实现是这样的，StripedBuffer维护一个Buffer[]数组，每个元素就是一个<code>RingBuffer</code>，每个线程用自己<code>threadLocalRandomProbe</code>属性作为hash值，这样就相当于每个线程都有自己“专属”的RingBuffer，就不会产生竞争啦，而不是用key的hashCode作为hash值，因为会产生热点数据问题。</p><p>看看StripedBuffer的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Table of buffers. When non-null, size is a power of 2. */</span></span><br><span class="line"><span class="comment">//RingBuffer数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Buffer&lt;E&gt; <span class="meta">@Nullable</span>[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当进行resize时，需要整个table锁住。tableBusy作为CAS的标记。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TABLE_BUSY = UnsafeAccess.objectFieldOffset(StripedBuffer.class, <span class="string">"tableBusy"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE = UnsafeAccess.objectFieldOffset(Thread.class, <span class="string">"threadLocalRandomProbe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of CPUS. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The bound on the table size. */</span></span><br><span class="line"><span class="comment">//table最大size</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_TABLE_SIZE = <span class="number">4</span> * ceilingNextPowerOfTwo(NCPU);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The maximum number of attempts when trying to expand the table. */</span></span><br><span class="line"><span class="comment">//如果发生竞争时（CAS失败）的尝试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTEMPTS = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Table of buffers. When non-null, size is a power of 2. */</span></span><br><span class="line"><span class="comment">//核心数据结构</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Buffer&lt;E&gt; <span class="meta">@Nullable</span>[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Spinlock (locked via CAS) used when resizing and/or creating Buffers. */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> tableBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CASes the tableBusy field from 0 to 1 to acquire lock. */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casTableBusy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> UnsafeAccess.UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, TABLE_BUSY, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the probe value for the current thread. Duplicated from ThreadLocalRandom because of</span></span><br><span class="line"><span class="comment"> * packaging restrictions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getProbe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> UnsafeAccess.UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>offer</code>方法，当没初始化或存在竞争时，则扩容为2倍。</p><p>实际是调用<code>RingBuffer</code>的offer方法，把数据追加到RingBuffer后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  Buffer&lt;E&gt; buffer;</span><br><span class="line">  <span class="comment">//是否不存在竞争</span></span><br><span class="line">  <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">  Buffer&lt;E&gt;[] buffers = table</span><br><span class="line">  <span class="comment">//是否已经初始化</span></span><br><span class="line">  <span class="keyword">if</span> ((buffers == <span class="keyword">null</span>)</span><br><span class="line">      || (mask = buffers.length - <span class="number">1</span>) &lt; <span class="number">0</span></span><br><span class="line">      <span class="comment">//用thread的随机值作为hash值，得到对应位置的RingBuffer</span></span><br><span class="line">      || (buffer = buffers[getProbe() &amp; mask]) == <span class="keyword">null</span></span><br><span class="line">      <span class="comment">//检查追加到RingBuffer是否成功</span></span><br><span class="line">      || !(uncontended = ((result = buffer.offer(e)) != Buffer.FAILED))) &#123;</span><br><span class="line">    <span class="comment">//其中一个符合条件则进行扩容</span></span><br><span class="line">    expandOrRetry(e, uncontended);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles cases of updates involving initialization, resizing, creating new Buffers, and/or</span></span><br><span class="line"><span class="comment"> * contention. See above for explanation. This method suffers the usual non-modularity problems of</span></span><br><span class="line"><span class="comment"> * optimistic retry code, relying on rechecked sets of reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wasUncontended false if CAS failed before call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法比较长，但思路还是相对清晰的。</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"PMD.ConfusingTernary"</span>)</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">expandOrRetry</span><span class="params">(E e, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">    ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">    h = getProbe();</span><br><span class="line">    wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> collide = <span class="keyword">false</span>; <span class="comment">// True if last slot nonempty</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> attempt = <span class="number">0</span>; attempt &lt; ATTEMPTS; attempt++) &#123;</span><br><span class="line">    Buffer&lt;E&gt;[] buffers;</span><br><span class="line">    Buffer&lt;E&gt; buffer;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (((buffers = table) != <span class="keyword">null</span>) &amp;&amp; ((n = buffers.length) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((buffer = buffers[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tableBusy == <span class="number">0</span>) &amp;&amp; casTableBusy()) &#123; <span class="comment">// Try to attach new Buffer</span></span><br><span class="line">          <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123; <span class="comment">// Recheck under lock</span></span><br><span class="line">            Buffer&lt;E&gt;[] rs;</span><br><span class="line">            <span class="keyword">int</span> mask, j;</span><br><span class="line">            <span class="keyword">if</span> (((rs = table) != <span class="keyword">null</span>) &amp;&amp; ((mask = rs.length) &gt; <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; (rs[j = (mask - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>)) &#123;</span><br><span class="line">              rs[j] = create(e);</span><br><span class="line">              created = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            tableBusy = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (created) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>; <span class="comment">// Slot is now non-empty</span></span><br><span class="line">        &#125;</span><br><span class="line">        collide = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended) &#123; <span class="comment">// CAS already known to fail</span></span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.offer(e) != Buffer.FAILED) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= MAXIMUM_TABLE_SIZE || table != buffers) &#123;</span><br><span class="line">        collide = <span class="keyword">false</span>; <span class="comment">// At max size or stale</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!collide) &#123;</span><br><span class="line">        collide = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tableBusy == <span class="number">0</span> &amp;&amp; casTableBusy()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (table == buffers) &#123; <span class="comment">// Expand table unless stale</span></span><br><span class="line">            table = Arrays.copyOf(buffers, n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          tableBusy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        collide = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// Retry with expanded table</span></span><br><span class="line">      &#125;</span><br><span class="line">      h = advanceProbe(h);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((tableBusy == <span class="number">0</span>) &amp;&amp; (table == buffers) &amp;&amp; casTableBusy()) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="comment">// Initialize table</span></span><br><span class="line">        <span class="keyword">if</span> (table == buffers) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">          Buffer&lt;E&gt;[] rs = <span class="keyword">new</span> Buffer[<span class="number">1</span>];</span><br><span class="line">          rs[<span class="number">0</span>] = create(e);</span><br><span class="line">          table = rs;</span><br><span class="line">          init = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        tableBusy = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看看<code>RingBuffer</code>，注意RingBuffer是<code>BoundedBuffer</code>的内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/** The maximum number of elements per buffer. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assume 4-byte references and 64-byte cache line (16 elements per line)</span></span><br><span class="line"><span class="comment">//256长度，但是是以16为单位，所以最多存放16个元素</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPACED_SIZE = BUFFER_SIZE &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPACED_MASK = SPACED_SIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OFFSET = <span class="number">16</span>;	</span><br><span class="line"><span class="comment">//RingBuffer数组</span></span><br><span class="line"><span class="keyword">final</span> AtomicReferenceArray&lt;E&gt; buffer;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//插入方法</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> head = readCounter;</span><br><span class="line">   <span class="keyword">long</span> tail = relaxedWriteCounter();</span><br><span class="line">   <span class="comment">//用head和tail来限制个数</span></span><br><span class="line">   <span class="keyword">long</span> size = (tail - head);</span><br><span class="line">   <span class="keyword">if</span> (size &gt;= SPACED_SIZE) &#123;</span><br><span class="line">     <span class="keyword">return</span> Buffer.FULL;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//tail追加16</span></span><br><span class="line">   <span class="keyword">if</span> (casWriteCounter(tail, tail + OFFSET)) &#123;</span><br><span class="line">     <span class="comment">//用tail“取余”得到下标</span></span><br><span class="line">     <span class="keyword">int</span> index = (<span class="keyword">int</span>) (tail &amp; SPACED_MASK);</span><br><span class="line">     <span class="comment">//用unsafe.putOrderedObject设值</span></span><br><span class="line">     buffer.lazySet(index, e);</span><br><span class="line">     <span class="keyword">return</span> Buffer.SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果CAS失败则返回失败</span></span><br><span class="line">   <span class="keyword">return</span> Buffer.FAILED;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//用consumer来处理buffer的数据</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drainTo</span><span class="params">(Consumer&lt;E&gt; consumer)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> head = readCounter;</span><br><span class="line">   <span class="keyword">long</span> tail = relaxedWriteCounter();</span><br><span class="line">   <span class="comment">//判断数据多少</span></span><br><span class="line">   <span class="keyword">long</span> size = (tail - head);</span><br><span class="line">   <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">     <span class="keyword">int</span> index = (<span class="keyword">int</span>) (head &amp; SPACED_MASK);</span><br><span class="line">     E e = buffer.get(index);</span><br><span class="line">     <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// not published yet</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     buffer.lazySet(index, <span class="keyword">null</span>);</span><br><span class="line">     consumer.accept(e);</span><br><span class="line">     <span class="comment">//head也跟tail一样，每次递增16</span></span><br><span class="line">     head += OFFSET;</span><br><span class="line">   &#125; <span class="keyword">while</span> (head != tail);</span><br><span class="line">   lazySetReadCounter(head);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意，ring buffer的size（固定是16个）是不变的，变的是head和tail而已。</p><p>总的来说ReadBuffer有如下特点：</p><ul><li>使用 Striped-RingBuffer来提升对buffer的读写</li><li>用thread的hash来避开热点key的竞争</li><li>允许写入的丢失</li></ul><h4 id="WriteBuffer"><a href="#WriteBuffer" class="headerlink" title="WriteBuffer"></a>WriteBuffer</h4><p>writeBuffer跟readBuffer不一样，主要体现在使用场景的不一样。本来缓存的一般场景是读多写少的，读的并发会更高，且afterRead显得没那么重要，允许延迟甚至丢失。写不一样，写afterWrite不允许丢失，且要求尽量马上执行。Caffeine使用MPSC（Multiple Producer / Single Consumer）作为buffer数组，实现在<code>MpscGrowableArrayQueue</code>类，它是仿照JCTools的MpscGrowableArrayQueue来写的。</p><p>MPSC允许无锁的高并发写入，但只允许一个消费者，同时也牺牲了部分操作。</p><p>MPSC我打算另外分析，这里不展开了。</p><h3 id="TimerWheel"><a href="#TimerWheel" class="headerlink" title="TimerWheel"></a>TimerWheel</h3><p>除了支持<code>expireAfterAccess</code>和<code>expireAfterWrite</code>之外（Guava Cache也支持这两个特性），Caffeine还支持<code>expireAfter</code>。因为expireAfterAccess和expireAfterWrite都只能是固定的过期时间，这可能满足不了某些场景，譬如记录的过期时间是需要根据某些条件而不一样的，这就需要用户自定义过期时间。</p><p>先看看expireAfter的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">256L</span>)</span><br><span class="line">        .initialCapacity(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//.expireAfterAccess(2, TimeUnit.DAYS)</span></span><br><span class="line">        <span class="comment">//.expireAfterWrite(2, TimeUnit.HOURS)</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">1</span>, TimeUnit.HOURS)</span><br><span class="line">        <span class="comment">//自定义过期时间</span></span><br><span class="line">        .expireAfter(<span class="keyword">new</span> Expiry&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="comment">//返回创建后的过期时间</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterCreate</span><span class="params">(@NonNull String key, @NonNull String value, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//返回更新后的过期时间</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterUpdate</span><span class="params">(@NonNull String key, @NonNull String value, <span class="keyword">long</span> currentTime, @NonNegative <span class="keyword">long</span> currentDuration)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//返回读取后的过期时间</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterRead</span><span class="params">(@NonNull String key, @NonNull String value, <span class="keyword">long</span> currentTime, @NonNegative <span class="keyword">long</span> currentDuration)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .recordStats()</span><br><span class="line">        .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(@NonNull String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"value_"</span> + key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>通过自定义过期时间，使得不同的key可以动态的得到不同的过期时间。</p><p>注意，我把expireAfterAccess和expireAfterWrite注释了，因为这两个特性不能跟expireAfter一起使用。</p><p>而当使用了expireAfter特性后，Caffeine会启用一种叫“时间轮”的算法来实现这个功能。更多关于时间轮的介绍，可以看我的文章<a href="/posts/ec8df8c/" title="HashedWheelTimer时间轮原理分析">HashedWheelTimer时间轮原理分析</a>。</p><p>好，重点来了，为什么要用时间轮？</p><p>对expireAfterAccess和expireAfterWrite的实现是用一个<code>AccessOrderDeque</code>双端队列，它是FIFO的，因为它们的过期时间是固定的，所以在队列头的数据肯定是最早过期的，要处理过期数据时，只需要首先看看头部是否过期，然后再挨个检查就可以了。但是，如果过期时间不一样的话，这需要对accessOrderQueue进行排序&amp;插入，这个代价太大了。于是，Caffeine用了一种更加高效、优雅的算法-时间轮。</p><p>时间轮的结构：</p><p><img src="/images/Caffeine高性能设计剖析__7.png" alt="upload successful"></p><p>因为在我的对时间轮分析的文章里已经说了时间轮的原理和机制了，所以我就不展开Caffeine对时间轮的实现了。</p><p>Caffeine对时间轮的实现在<code>TimerWheel</code>，它是一种多层时间轮（hierarchical timing wheels ）。</p><p>看看元素加入到时间轮的<code>schedule</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedules a timer event for the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the entry in the cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(@NonNull Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">  Node&lt;K, V&gt; sentinel = findBucket(node.getVariableTime());</span><br><span class="line">  link(sentinel, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determines the bucket that the timer event should be added to.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time the time when the event fires</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the sentinel at the head of the bucket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K, V&gt; <span class="title">findBucket</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> duration = time - nanos;</span><br><span class="line">  <span class="keyword">int</span> length = wheel.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (duration &lt; SPANS[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">long</span> ticks = (time &gt;&gt;&gt; SHIFT[i]);</span><br><span class="line">      <span class="keyword">int</span> index = (<span class="keyword">int</span>) (ticks &amp; (wheel[i].length - <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">return</span> wheel[i][index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wheel[length][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds the entry at the tail of the bucket's list. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(Node&lt;K, V&gt; sentinel, Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">  node.setPreviousInVariableOrder(sentinel.getPreviousInVariableOrder());</span><br><span class="line">  node.setNextInVariableOrder(sentinel);</span><br><span class="line"></span><br><span class="line">  sentinel.getPreviousInVariableOrder().setNextInVariableOrder(node);</span><br><span class="line">  sentinel.setPreviousInVariableOrder(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###其他</p><p>Caffeine还有其他的优化性能的手段，如使用软引用和弱引用、消除伪共享、CompletableFuture异步等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Caffeien是一个优秀的本地缓存，通过使用W-TinyLFU算法， 高性能的readBuffer和WriteBuffer，时间轮算法等，使得它拥有高性能，高命中率（near optimal），低内存占用等特点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://arxiv.org/abs/1512.00727" rel="external nofollow noopener noreferrer" target="_blank">TinyLFU论文</a></p><p><a href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html" rel="external nofollow noopener noreferrer" target="_blank">Design Of A Modern Cache</a></p><p><a href="http://highscalability.com/blog/2019/2/25/design-of-a-modern-cachepart-deux.html" rel="external nofollow noopener noreferrer" target="_blank">Design Of A Modern Cache—Part Deux</a></p><p><a href="https://github.com/ben-manes/caffeine" rel="external nofollow noopener noreferrer" target="_blank">Caffeine的github</a></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"># java</a> <a href="/tags/cache/" rel="tag"># cache</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/6518ba8/" rel="next" title="Striped64和LongAdder"><i class="fa fa-chevron-left"></i> Striped64和LongAdder</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/f00ab7dc/" rel="prev" title="MpscGrowableArrayQueue分析">MpscGrowableArrayQueue分析 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="alben.wong"><p class="site-author-name" itemprop="name">alben.wong</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">58</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a rel="external nofollow" href="huangyibin1989@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要"><span class="nav-number">1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与Guava-Cache比较"><span class="nav-number">2.</span> <span class="nav-text">与Guava Cache比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Caffeine"><span class="nav-number">3.</span> <span class="nav-text">使用Caffeine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Caffeine的高性能设计"><span class="nav-number">4.</span> <span class="nav-text">Caffeine的高性能设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#W-TinyLFU整体设计"><span class="nav-number">4.1.</span> <span class="nav-text">W-TinyLFU整体设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU和LFU的缺点"><span class="nav-number">4.1.1.</span> <span class="nav-text">LRU和LFU的缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TinyLFU"><span class="nav-number">4.1.2.</span> <span class="nav-text">TinyLFU</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#统计频率Count–Min-Sketch算法"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">统计频率Count–Min Sketch算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#保新机制"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">保新机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增加一个Window？"><span class="nav-number">4.1.3.</span> <span class="nav-text">增加一个Window？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#淘汰策略（eviction-policy）"><span class="nav-number">4.1.4.</span> <span class="nav-text">淘汰策略（eviction policy）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步的高性能读写"><span class="nav-number">4.2.</span> <span class="nav-text">异步的高性能读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadBuffer"><span class="nav-number">4.2.1.</span> <span class="nav-text">ReadBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WriteBuffer"><span class="nav-number">4.2.2.</span> <span class="nav-text">WriteBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TimerWheel"><span class="nav-number">4.3.</span> <span class="nav-text">TimerWheel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">alben.wong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">84.6k</span></div><div class="powered-by">由 <a rel="external nofollow noopener noreferrer" class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a rel="external nofollow noopener noreferrer" class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'xpCAj9IO0r0lXC1DpoTEPkMY-gzGzoHsz',
        appKey: 'UinOlExejD79tH248UO6oNIf',
        placeholder: '走过路过，不留下点什么吗？',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script><script type="text/javascript">// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("xpCAj9IO0r0lXC1DpoTEPkMY-gzGzoHsz","UinOlExejD79tH248UO6oNIf")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script></body></html>